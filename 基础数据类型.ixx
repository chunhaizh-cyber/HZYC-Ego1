module;
#include <afx.h>
//#include <vector>
//#include <variant>

export module 基础数据类型模块;
import <variant>;
 import <string>;
import <vector>;

export enum class 枚举_比较条件 { 相等, 大于, 小于, 不等于, 包含, 除外 };
export enum class 枚举_比较字段 {
    //特征值类//
    名称,
    类型,
    值,
    //语素类//
    语素_词_词,

    语素_词性_词性,
    语素_词性_对应基础信息指针,

    语素_短语字节点_参照词,
    语素_短语字节点_比较对象词,
    语素_短语子节点_比较词,
    语素_短语子节点_结果词,
    //基础类
    基础信息_矢量特征值_类型,
    基础信息_矢量特征值_单位,
    基础信息_矢量特征值_值,

    基础信息_非矢量特征值_类型,
    基础信息_非矢量特征值_值,

    基础信息基类_名称,
    基础信息基类_类型,
    基础信息_指代节点_代词,
    基础信息_指代节点_指代对象,

    基础信息_特征节点_类型,
    基础信息_特征节点_值,
    基础信息_特征节点_名称,

    基础信息_存在节点_绝对坐标_z轴,
    基础信息_存在节点_绝对坐标_y轴,
    基础信息_存在节点_绝对坐标_x轴,

    基础信息_场景节点_绝对坐标_z轴,
    基础信息_场景节点_绝对坐标_y轴,
    基础信息_场景节点_绝对坐标_x轴,

    基础信息_状态节点主信息类_收到时间,
    基础信息_状态节点主信息类_发生时间,
    基础信息_状态节点主信息类_是否变化,

   


    实例信息,
    词性词指针,
    原始短语,
    词指针,
    单位,
    状态类型_特征,
    状态类型_存在,
    状态类型_场景,
    产生需求主体,
    需求对象,
    需求状态,
   
    // ...已有字段
    评估_覆盖率, 评估_指代解析率, 评估_一致性_冲突数,
    评估_可执行性, 评估_全局置信度,
    评估_时间对齐误差, 评估_空间对齐误差,
    评估_比较正确率, 评估_否定正确率, 评估_程度正确率


};

export enum class 枚举_任务类型{普通任务,思考任务,尝试任务,学习任务};
export enum class 枚举_基础方法 {添加存在,添加特征,添加场景,未定义, 外部调用};

//============================ 通用枚举（保留） ============================
export enum class 枚举_主信息类型 {
    指代, 非矢量特征值, 矢量特征值, 短语子, 基础信息基类, 语素基类,
    词, 词性, 短语, 特征, 特征_特征, 特征_存在, 存在,
    场景, 状态的特征, 动态的特征, 状态_特征, 状态_存在, 状态_场景,
    动态, 因果, 关系, 其它, 存在信息, 存在信息_指代, 动态信息, 特征信息,
    二次特征_修饰, 特征信息_数量, 关系信息, 情绪特征信息, 情绪调节信息, 语言信息_仅记录
};

export enum class 枚举_词性 {
    // 原有枚举项
    名词, 动词, 形容词, 副词, 连词, 介词, 专有名词, 抽象名词, 代词, 数词, 量词, 助词, 叹词,
    拟声词, 标点符号, 时间词, 状态词, 方位词, 习用语, 简称略语, 非语素字, 语气词, 外文字符, 未定义,
    地名,
    // 新增词性（按照你提供的格式对应）
    n, // 普通名词
    f, // 方位名词
    s, // 处所名词
    t, // 时间名词
    nr, // 人名
    ns, // 地名（与原有“地名”重复概念，实际使用中可能需要处理冲突，这里保留原样展示）
    nt, // 机构团体名
    nw, // 作品名
    nz, // 其他专名
    v, // 普通动词
    vd, // 动副词
    vn, // 名动词
    a, // 形容词
    ad, // 副形词
    an, // 名形词
    d, // 副词
    m, // 数量词
    q, // 量词
    r, // 代词
    p, // 介词
    c, // 连词
    u, // 助词
    xc, // 其他虚词
    w, // 标点符号

    // 专名识别缩略词
    PER, // 人名
    LOC, // 地名
    ORG, // 机构名
    TIME  // 时间
};
export struct 结构体_分词 {
    std::wstring 词;
    std::wstring  词性;
    结构体_分词() = default;
    结构体_分词(std::wstring 词_, std::wstring  词性_)
        :词(词_), 词性(词性_) {
    }

};
//============================ 空间/几何 ============================
export struct 结构体_空间坐标 {
    long long x = 0, y = 0, z = 0;
    friend bool operator==(const 结构体_空间坐标& a, const 结构体_空间坐标& b) {
        return a.x == b.x && a.y == b.y && a.z == b.z;
    }
    结构体_空间坐标 operator-(const 结构体_空间坐标& o) const {
        return { x - o.x, y - o.y, z - o.z };
    }
};
export enum class 结构体_轮廓类型 { 盒子, 球体, 圆柱, 自定义 };
export struct 结构体_简单轮廓信息 {
    结构体_轮廓类型 类型 = 结构体_轮廓类型::盒子;
    结构体_空间坐标 中心坐标{};
    结构体_空间坐标 尺寸{};
    long long 半径 = 0;
    friend bool operator==(const 结构体_简单轮廓信息& a, const 结构体_简单轮廓信息& b) {
        return a.类型 == b.类型 && a.中心坐标 == b.中心坐标 && a.尺寸 == b.尺寸 && a.半径 == b.半径;
    }
    结构体_简单轮廓信息 operator-(const 结构体_简单轮廓信息& o) const {
        auto 类型_ = (类型 == o.类型) ? 类型 : 结构体_轮廓类型::自定义;
        return { 类型_, 中心坐标 - o.中心坐标, 尺寸 - o.尺寸, 半径 - o.半径 };
    }
};

// === 消息定义 ===
export namespace 消息类型 {
    enum 消息代码 {

        新任务 = WM_USER + 200,
        任务完成 = WM_USER + 250,
        空任务= WM_USER + 251,
        任务不可执行 = WM_USER + 252,       
        任务无实例化方法 = WM_USER + 253,

        分词请求 = WM_USER + 260,
        分词完成 = WM_USER + 261,
        ///////////////////////////////////////////////////      
        新任务_完善词信息 = WM_USER + 300,

        ///////////////////////////////////////////////////
        自我_安全值变化= WM_USER + 900,
        消息_退出= WM_USER + 1,

    };
 
    constexpr const  wchar_t* 名称(消息代码 消息) noexcept {
        switch (消息) {
        case 新任务: return L"新任务";
        case 任务完成: return L"任务完成";
        case 空任务: return L"空任务";
        case 任务不可执行: return L"任务不可执行";
        case 任务无实例化方法: return L"任务不可执行";            
            
        case 分词请求: return L"分词请求";
        case 分词完成: return L"分词完成";
        case 新任务_完善词信息: return L"新任务_完善词信息";
        case 自我_安全值变化: return L"自我_安全值变化";
        case 消息_退出: return L"消息_退出";
        default: return L"未知消息";
        }
    }
}
// === 消息参数 ===
export struct 消息参数 {
    std::variant<int64_t, std::wstring, std::vector<std::wstring>, void*> 数据;

    消息参数(int64_t 值) : 数据(值) {}
    消息参数(std::wstring 值) : 数据(std::move(值)) {}
    消息参数(std::vector<std::wstring> 值) : 数据(std::move(值)) {}
    消息参数(void* 值) : 数据(值) {}

    template <typename T>
    消息参数(T) = delete;

    bool 是整数()  const { return std::holds_alternative<int64_t>(数据); }
    int64_t 取整数()  { return std::get<int64_t>(数据); }
};
// 消息结构体
//export struct 消息 {
//    消息类型::消息代码 消息类型;   
//    std::vector<std::variant<int64_t, std::wstring, std::vector<std::wstring>, void*>> 参数列表;
//    消息(消息类型::消息代码 消息类型_, std::variant<int64_t, std::wstring, std::vector<std::wstring>, void*> 数据) {
//        消息类型 = 消息类型_;
//        参数列表.push_back(数据);
//    }
//    消息() {}
//    
//};

export enum class 枚举_语言用途 {
    存在_陈述, 特征_描述, 事件_叙述, 关系_布局, 比较_排序,
    数量_范围, 否定_排除, 疑问_信息需求, 指令_意图,
    条件_假设, 因果_解释, 时间_体貌, 评价_立场,
    来源_引述, 定义_分类, 角色_标注, 约束_义务, 例外_对照, 单位_度量
};

export enum class 枚举_因果来源{ 文本描述,实验观察,他人报告 };
export enum class  枚举_验证状态 {未验证,弱验证,强验证,被推翻 };
export enum class  枚举_方法来源 { 文本理解, 自我实践, 他人经验 };
export enum class  枚举_实践状态 { 未验证, 部分验证, 已验证, 已否定 };

///////////////////////////////方法类相关///////////////////////////////////////////////////
export enum class 枚举_本能函数ID : std::uint16_t {
    未定义 = 0,
    // 例如：
    比较特征_时间,
    比较特征_对象,
    阈值判断,
    空间拓扑判断,
    时间顺序判断,
    存在判断,
    // ...
};

// 方法属于哪一层/哪种语义用途
export enum class 枚举_方法语义大类 : std::uint8_t {
    描述层,     // 场景/状态/动态构建
    判断层,     // 二次特征/判据计算
    应用层,     // 任务/决策/执行
    语言解析,   // 语言 -> 场景
    语言生成,   // 场景 -> 语言
    学习层      // 参数更新/方法抽象
};

// 头节点动作的执行方式
export enum class 枚举_动作执行方式 : std::uint8_t {
    无动作,      // 纯分发/决策
    直接本能,    // 直接调用某个本能函数
    子方法       // 调用另一个方法树
};
////////////////////////////////////////////////////////////////////////////////////